;;; simply.scm
;;; Based on berkeley.scm version.

(if (equal? 'foo (symbol->string 'foo))
    (error "Simply.scm already laoded!")
    #f)

;; number->string remove leading "+"
(if (char=? #\+ (string-ref (number->string 1.0) 0))
    (let ((old-ns number->string)
	  (char=? char=?)
	  (string-ref string-ref)
	  (substring substring)
	  (string-length string-length)
	  )
      (set! number->string
	(lambda args
	  (let ((result (apply old-ns args)))
	    (if (char=? #\+ (string-ref result 0))
		(substring result 1 (string-length result))
		result)
	    )))
      )
    'no-problem
    )

(define number->string
  (let ((old-ns number->string)
	(string? string?))
    (lambda args
      (if (string? (car args))
	  (car args)
	  (apply old-ns args)))
    ))

;; Get strings in error messages to print nicely (especially "")
(define whoops
  (let ((string? string?)
	(string-append string-append)
	(error error)
	(cons cons)
	(map map)
	(apply apply))
    (define (error-printform x)
      (if (string? x)
	  (string-append "\"" x "\"")
	  x)
      )
    (lambda (string . args)
      (apply error
	     (cons string (map error-printform args))))
    ))

(if (and (inexact? (round (sqrt 2))) (exact? 1))
    (let ((old-round round)
	  (inexact->exact inexact->exact))
      (set! round
	(lambda (number)
	  (inexact->exact (old-round number)))))
    'no-problem)

;; Remainder and quotient blow up if their argument isn'tan integer
(if (inexact? (* .25 4))
    (let ((rem remainder)
	  (quo quotient)
	  (inexact->exact inexact->exact)
	  (integer? integer?))
      (set! remainder
	(lambda (x y)
	  (rem (if (integer? x) (inexact->exact x) x)
	       (if (integer? y) (inexact->exact y) y)
	       )
	  ))
      (set! quotient
	(lambda (x y)
	  (quo (if (integer? x) (inexact->exact x) x)
	       (if (integer? y) (inexact->exact y) y))))
      )
    'done)

;; Random
(define random
  (let ((*seed* 1)
	(quotient quotient)
	(modulo modulo)
	(+ +)
	(- -)
	(* *)
	(> >))
    (lambda (x)
      (let* ((hi (quotient *seed* 127773))
	     (low (modulo *seed* 127773))
	     (test (- (* 16807 low) (* 2836 hi))))
	(if (> test 0)
	    (set! *seed* test)
	    (set! *seed* (+ test 2147483647)))
	)
      (modulo *seed* x)
      )
    )
  )

;; Logo style word/sentence implementations
(define word?
  (let ((number? number?)
	(symbol? symbol?)
	(string? string?))
    (lambda (x)
      (or (symbol? x) (number? x) (string? x))
      )
    )
  )

(define sentence?
  (let ((null? null?)
	(pair? pair?)
	(word? word?)
	(car car)
	(cdr cdr))
    (define (list-of-words? l)
      (cond ((null? l) #t)
	    ((pair? l)
	     (and (word? (car l))
		  (list-of-words? (cdr l))))
	    (else #f)))
    list-of-words?
    ))

(define empty?
  (let ((null? null?)
	(string? string?)
	(string=? string=?))
    (lambda (x)
      (or (null? x)
	  (and (string? x) (string=? x ""))))))


;; 0 Letter in good case or special initial
;; 1 .,+ or -
;; 2 Digit
;; 3 Letter in bad case or weird character
(define char-rank
  (let ((*the-char-ranks* (make-vector 256 3))
	(= =)
	(+ +)
	(string-ref string-ref)
	(string-length string-length)
	(vector-set! vector-set!)
	(char->integer char->integer)
	(symbol->string symbol->string)
	(vector-ref vector-ref))
    (define (rank-string str rank)
      (define (helper i len)
	(if (= i len)
	    'done
	    (begin (vector-set! *the-char-ranks*
				(char->integer (string-ref str i))
				rank)
		   (helper (+ i 1) len))))
      (helper 0 (string-length str)))
    (rank-string (symbol->string 'abcdefghijklmnopqrstuvwxyz) 0)
    (rank-string "!$%&*/:<=>?~_^" 0)
    (rank-string "+-." 1)
    (rank-string "0123456789" 2)
    (lambda (char)
      (vector-ref *the-char-ranks* (char->integer char)))
    ))

(define string->word
  (let ((= =)
	(<= <=)
	(+ +)
	(- -)
	(char-rank char-rank)
	(string-ref string-ref)
	(string-length string-length)
	(string=? string=?)
	(not not)
	(char=? char=?)
	(string->number string->number)
	(string->symbol string->symbol))
    (lambda (string)
      (define (subsequents? string i length)
	(cond ((= i length) #t)
	      ((<= (char-rank (string-ref string i)) 2)
	       (subsequents? string (+ i 1) length))
	      (else #f)))
      (define (special-id? string)
	(or (string=? string "+")
	    (string=? string "-")
	    (string=? string "...")))
      (define (ok-symbol? string)
	(if (string=? string "")
	    #f
	    (let ((rank1 (char-rank (string-ref string 0))))
	      (cond ((= rank1 0) (subsequents? string 1 (string-length string)))
		    ((= rank1 1) (special-id? string))
		    (else #f)))))
      (define (nn-helper string i len seen-point?)
	(cond ((= i len)
	       (if seen-point?
		   (not (char=? (string-ref string (- len 1)) #\0))
		   #t))
	      ((char=? #\. (string-ref string i))
	       (cond (seen-point? #f)
		     ((= (+ i 2) len) #t)
		     (else (nn-helper string (+ i 1) len #t))))
	      ((= 2 (char-rank (string-ref string i)))
	       (nn-helper string (+ i 1) len seen-point?))
	      (else #f)
	      ))
      (define (narrow-number? string)
	(if (string=? string "")
	    #f
	    (let* ((c0 (string-ref string 0))
		   (start 0)
		   (len (string-length string))
		   (cn (string-ref string (- len 1))))
	      (if (and (char=? c0 #\-) (not (= len 1)))
		  (begin
		    (set! start 1)
		    (set! c0 (string-ref string 1)))
		  #f)
	      (cond ((not (= (char-rank cn) 2)) #f)
		    ((char=? c0 #\.) #f)
		    ((char=? c0 #\0)
		     (cond ((= len 1) #t)
			   ((= len 2) #f)
			   ((char=? (string-ref string (+ start 1)) #\.)
			    (nn-helper string (+ start 2) len #t))
			   (else #f)))
		    (else (nn-helper string start len #f)))
	      ))
	)
      ;; The body of string->word
      (cond ((narrow-number? string) (string->number string))
	    ((ok-symbol? string) (string->symbol string))
	    (else string)))))

(define char->word
  (let ((= =)
	(char-rank char-rank)
	(make-string make-string)
	(string->symbol string->symbol)
	(string->number string->number)
	(char=? char=?))
    (lambda (char)
      (let ((rank (char-rank char))
	    (string (make-string 1 char)))
	(cond ((= rank 0) (string->symbol string))
	      ((= rank 2) (string->number string))
	      ((char=? char #\+) '+)
	      ((char=? char #\-) '-)
	      (else string))))))

(define word->string
  (let ((number? number?)
	(string? string?)
	(number->string number->string)
	(symbol->string symbol->string))
    (lambda (wd)
      (cond ((string? wd) wd)
	    ((number? wd) (number->string wd))
	    (else (symbol->string wd)))))
  )
(define count
  (let ((word? word?)
	(string-length string-length)
	(word->string word->string)
	(length length))
    (lambda (stuff)
      (if (word? stuff)
	  (string-length (word->string stuff))
	  (length stuff)))))

(define word
  (let ((string->word string->word)
	(apply apply)
	(string-append string-append)
	(map map)
	(word? word?)
	(word->string word->string)
	(whoops whoops))
    (lambda x
      (string->word
       (apply string-append
	      (map (lambda (arg)
		     (if (word? arg)
			 (word->string arg)
			 (whoops "Invalid argument to WORD: " arg)))
		   x)
	      )))))

(define se
  (let ((pair? pair?)
	(null? null?)
	(word? word?)
	(car car)
	(cdr cdr)
	(cons cons)
	(whoops whoops))
    (define (paranoid-append a original-a b)
      (cond ((null? a) b)
	    ((word?  (car a))
	     (cons (car a) (paranoid-append (cdr a) original-a b)))
	    (else (whoops "Argument to SENTENCE not a word or sentence" original-a))))
    (define (combine-two a b)
      (cond ((pair? a) (paranoid-append a a b))
	    ((null? a) b)
	    ((word? a) (cons a b))
	    (else (whoops "Argument to SENTENCE not a word or sentence: " a))))
    (define (real-se args)
      (if (null? args)
	  '()
	  (combine-two (car args) (real-se (cdr args)))))
    (lambda args
      (real-se args))
    ))

(define sentence se)

(define first
  (let ((pair? pair?)
	(char->word char->word)
	(string-ref string-ref)
	(word->string word->string)
	(car car)
	(empty? empty?)
	(whoops whoops)
	(word? word?))
    (define (word-first wd)
      (char->word (string-ref (word->string wd) 0)))
    (lambda (x)
      (cond ((pair? x) (car x))
	    ((empty? x) (whoops "Invalid argument to FIRST: " x))
	    ((word? x) (word-first x))
	    (else (whoops "Invalid argument to FIRST: " x))))
    ))

(define last
  (let ((pair? pair?)
	(- -)
	(word->string word->string)
	(char->word char->word)
	(string-ref string-ref)
	(string-length string-length)
	(empty? empty?)
	(cdr cdr)
	(car car)
	(whoops whoops)
	(word? word?))
    (define (word-last wd)
      (let ((s (word->string wd)))
	(char->word (string-ref s (- (string-length s) 1)))))
    (define (list-last lst)
      (if (empty? (cdr lst))
	  (car lst)
	  (list-last (cdr lst))))
    (lambda (x)
      (cond ((pair? x) (list-last x))
	    ((empty? x) (whoops "Invalid argument to LAST: " x))
	    ((word? x) (word-last x))
	    (else (whoops "Invalid argument to LAST: " x))))
    ))

(define bf
  (let ((pair? pair?)
	(substring substring)
	(string-length string-length)
	(string->word string->word)
	(word->string word->string)
	(cdr cdr)
	(empty? empty?)
	(whoops whoops)
	(word? word?))
    (define string-bf
      (lambda (s)
	(substring s 1 (string-length s))))
    (define (word-bf wd)
      (string->word (string-bf (word->string wd))))
    (lambda (x)
      (cond ((pair? x) (cdr x))
	    ((empty? x) (whoops "Invalid argument to BUTFIRST: " x))
	    ((word? x) (word-bf x))
	    (else (whoops "Invalid argument to BUTFIRST: " x))))))

(define butfirst bf)

(define bl
  (let ((pair? pair?)
	(- -)
	(cons cons)
	(car car)
	(substring substring)
	(string-length string-length)
	(string->word string->word)
	(word->string word->string)
	(empty? empty?)
	(whoops whoops)
	(word? word?))
    (define (list-bl list)
      (if (null? (cdr list))
	  '()
	  (cons (car list) (list-bl (cdr list)))))
    (define (string-bl s)
      (substring s 0 (- (string-length s) 1)))
    (define (word-bl wd)
      (string->word (string-bl (word->string wd)))
      )
    (lambda (x)
      (cond ((pair? x) (list-bl x))
	    ((empty? x) (whoops "Invalid argument to BUTLAST: " x))
	    ((word? x) (word-bl x))
	    (else (whoops "Invalid argument to BUTLAST: " x))))
    ))
(define butlast bl)

(define item
  (let ((> >)
	(- -)
	(< <)
	(integer? integer?)
	(list-ref list-ref)
	(char->word char->word)
	(string-ref string-ref)
	(word->string word->string)
	(not not)
	(whoops whoops)
	(count count)
	(word? word?)
	(list? list?))
    (define (word-item n wd)
      (char->word (string-ref (word->string wd) (- n 1))))
    (lambda (n stuff)
      (cond ((not (integer? n))
	     (whoops "Invalid first argument to ITEM (must be an integer):" n))
	    ((< n 1)
	     (whoops "Invalid first argument to ITEM (must be positive):" n))
	    ((> n (count stuff))
	     (whoops "No such item:" n stuff))
	    ((word? stuff) (word-item n stuff))
	    ((list? stuff) (list-ref stuff (- n 1)))
	    (else (whoops "Invalid second argument to ITEM: " stuff))))
    ))

(define equal?
  (let ((vector-length vector-length)
	(= =)
	(vector-ref vector-ref)
	(+ +)
	(string? string?)
	(symbol? symbol?)
	(null? null?)
	(pair? pair?)
	(car car)
	(cdr cdr)
	(eq? eq?)
	(string=? string=?)
	(symbol->string symbol->string)
	(number? number?)
	(string->word string->word)
	(vector? vector?)
	(eqv? eqv?))
    (define (vector-equal? v1 v2)
      (let ((len1 (vector-length v1))
	    (len2 (vector-length v2)))
	(define (helper i)
	  (if (= i len1)
	      #t
	      (and (equal? (vector-ref v1 i) (vector-ref v2 i))
		   (helper (+ i 1)))))
	(if (= len1 len2)
	    (helper 0)
	    #f)
	))
    (lambda (x y)
      (cond ((null? x) (null? y))
	    ((null? y) #f)
	    ((pair? x)
	     (and (pair? y)
		  (equal? (car x) (car y))
		  (equal? (cdr x) (cdr y))))
	    ((pair? y) #f)
	    ((symbol? x)
	     (or (and (symbol? y) (eq? x y))
		 (and (string? y) (string=? (symbol->string x) y))))
	    ((symbol? y)
	     (and (string? x) (string=? x (symbol->string y))))
	    ((number? x)
	     (or (and (number? y) (= x y))
		 (and (string? y)
		      (let ((possible-num (string->word y)))
			(and (number? possible-num)
			     (= x possible-num))))))
	    ((number? y)
	     (and (string? x)
		  (let ((possible-num (string->word x)))
		    (and (number? possible-num)
			 (= possible-num y)))))
	    ((string? x) (and (string? y) (string=? x y)))
	    ((string? y) #f)
	    ((vector? x) (and (vector? y) (vector-equal? x y)))
	    ((vector? y) #f)
	    (else (eqv? x y))
	    ))
    ))

(define member?
  (let ((> >) (- -) (< <) (null? null?)
	(symbol? symbol?)
	(eq? eq?)
	(car car)
	(cdr cdr)
	(not not)
	(symbol->string symbol->string)
	(string=? string=?)
	(equal? equal?)
	(word->string word->string)
	(string-length string-length)
	(whoops whoops)
	(string-ref string-ref)
	(char=? char=?)
	(list? list?)
	(number? number?)
	(empty? empty?)
	(word? word?)
	(string? string?))
    (define (symbol-in-list? symbol string lst)
      (cond ((null? lst) #f)
	    ((and (symbol? (car lst))
		  (eq? symbol (car lst))))
	    ((string? (car lst))
	     (cond ((not string)
		    (symbol-in-list? symbol (symbol->string symbol) lst))
		   ((string=? string (car lst)) #t)
		   (else (symbol-in-list? symbol string (cdr lst)))))
	    (else (symbol-in-list? symbol string (cdr lst)))))
    (define (word-in-list? wd lst)
      (cond ((null? lst) #f)
	    ((equal? wd (car lst)) #t)
	    (else (word-in-list? wd (cdr lst))))
      )
    (define (word-in-word? small big)
      (let ((one-letter-str (word->string small)))
	(if (> (string-length one-letter-str) 1)
	    (whoops "Invalid arguments to MEMBER?:" small big)
	    (let ((big-str (word->string big)))
	      (char-in-string? (string-ref one-letter-str 0)
			       big-str
			       (- (string-length big-str) 1))))))
    (define (char-in-string? char string i)
      (cond ((< i 0) #f)
	    ((char=? char (string-ref string i)) #t)
	    (else (char-in-string? char string (- i 1)))))
    (lambda (x stuff)
      (cond ((empty? stuff) #f)
	    ((word? stuff) (word-in-word? x stuff))
	    ((not (list? stuff))
	     (whoops "Invalid second argument to MEMBER?: " stuff))
	    ((symbol? x) (symbol-in-list? x #f stuff))
	    ((or (number? x) (string? x))
	     (word-in-list? x stuff))
	    (else (whoops "Invalid first argument to MEMBER?: " x))))
    ))

(define before?
  (let ((not not)
	(word? word?)
	(whoops whoops)
	(string<? string<?)
	(word->string word->string))
    (lambda (wd1 wd2)
      (cond ((not (word? wd1))
	     (whoops "Invalid first argument to BEFORE? (not a word):" wd1))
	    ((not (word? wd2))
	     (whoops "Invalid second argument to BEFORE? (not a word):" wd2))
	    (else (string<? (word->string wd1) (word->string wd2)))))))

;;; Higher Order Functions
(define filter
  (let ((null? null?)
	(car car)
	(cdr cdr)
	(cons cons)
	(not not)
	(procedure? procedure?)
	(whoops whoops)
	(list? list?))
    (lambda (pred l)
      ;; Helper function so recursive calls don't show up in TRACE
      (define (real-filter l)
	(cond ((null? l) '())
	      ((pred (car l))
	       (cons (car l) (real-filter (cdr l))))
	      (else (real-filter (cdr l)))))
      (cond ((not (procedure? pred))
	     (whoops "Invalid first argument to FILTER (not a procedure): " pred))
	    ((not (list? l))
	     (whoops "Invalid second argument to FILTER (not a list): " l))
	    (else (real-filter l)))
      )))

(define keep
  (let ((+ +) (= =) (pair? pair?)
	(substring substring)
	(char->word char->word)
	(string-ref string-ref)
	(string-set! string-set!)
	(word->string word->string)
	(string-length string-length)
	(string->word string->word)
	(make-string make-string)
	(procedure? procedure?)
	(whoops whoops)
	(word? word?)
	(null? null?))
    (lambda (pred w-or-s)
      (define (keep-string in i out out-len len)
	(cond ((= i len) (substring out 0 out-len))
	      ((pred (char->word (string-ref in i)))
	       (string-set! out out-len (string-ref in i))
	       (keep-string in (+ i 1) out (+ out-len 1) len))
	      (else (keep-string in (+ i 1) out out-len len))))
      (define (keep-word wd)
	(let* ((string (word->string wd))
	       (len (string-length string)))
	  (string->word
	   (keep-string string 0 (make-string len) 0 len))))
      (cond ((not (procedure? pred))
	     (whoops "Invalid first argument to KEEp (not a procedure):" pred))
	    ((pair? w-or-s) (filter pred w-or-s))
	    ((word? w-or-s) (keep-word w-or-s))
	    ((null? w-or-s) '())
	    (else
	     (whoops "Bad second argument to KEEP (not a word or sentence): "
		     w-or-s))))))



